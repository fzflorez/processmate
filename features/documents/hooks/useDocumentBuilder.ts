/**
 * Document Builder Hook
 * Manages document generation state and AI-powered question flow
 */

import { useState, useCallback, useRef } from "react";
import type {
  DocumentBuilderState,
  DocumentTemplate,
  DocumentAnswer,
  Document,
  DocumentGenerationRequest,
  DocumentGenerationResponse,
  DocumentExportOptions,
} from "../types";
import {
  validateDocumentAnswer,
  validateDocumentGenerationRequest,
  validateDocumentExportOptions,
} from "../schemas";

// Simple UUID generator
const generateUUID = (): string => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
};

// Mock AI Service (replace with actual implementation)
class MockDocumentAIService {
  async generateDocument(
    request: DocumentGenerationRequest,
  ): Promise<DocumentGenerationResponse> {
    // Simulate AI processing time
    await new Promise((resolve) => setTimeout(resolve, 2000));

    // Create mock document based on answers
    const answersText = request.answers
      .map(
        (answer) =>
          `${answer.questionId}: ${Array.isArray(answer.value) ? answer.value.join(", ") : answer.value}`,
      )
      .join("\n");

    const mockDocument: Document = {
      id: generateUUID(),
      title: `Generated Document - ${new Date().toLocaleDateString()}`,
      description: "Document generated from AI responses",
      content: `# Generated Document\n\nBased on your answers:\n\n${answersText}\n\n## Additional Content\n\nThis is a mock document generated by the AI service. In a real implementation, this would contain rich, contextual content based on your specific requirements and answers.\n\n### Key Points\n- Content tailored to your responses\n- Professional formatting\n- Comprehensive coverage of your needs`,
      sections: [
        {
          id: generateUUID(),
          title: "Introduction",
          content:
            "This document was generated based on your specific requirements.",
          order: 1,
          type: "paragraph",
        },
        {
          id: generateUUID(),
          title: "Summary",
          content: answersText,
          order: 2,
          type: "paragraph",
        },
        {
          id: generateUUID(),
          title: "Details",
          content:
            "Detailed content would be generated here based on the AI analysis of your answers.",
          order: 3,
          type: "paragraph",
        },
      ],
      templateId: request.templateId,
      answers: request.answers,
      metadata: {
        wordCount: 150,
        readingTime: 2,
        format: "markdown",
        language: "en",
      },
      status: "draft",
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: "user",
      version: 1,
    };

    return {
      document: mockDocument,
      usage: {
        promptTokens: 100,
        completionTokens: 200,
        totalTokens: 300,
      },
      processingTime: 2000,
    };
  }

  async askDynamicQuestion(): Promise<string> {
    // Simulate dynamic question generation
    await new Promise((resolve) => setTimeout(resolve, 1000));

    const questions = [
      "Could you provide more details about your specific requirements?",
      "What is the target audience for this document?",
      "Are there any specific formatting guidelines you need to follow?",
      "What is the desired tone or style for this document?",
      "Do you need any specific sections or chapters included?",
    ];

    return questions[Math.floor(Math.random() * questions.length)];
  }
}

interface UseDocumentBuilderOptions {
  userId: string;
  aiService?: MockDocumentAIService;
}

export function useDocumentBuilder({
  aiService = new MockDocumentAIService(),
}: UseDocumentBuilderOptions) {
  // State management
  const [state, setState] = useState<DocumentBuilderState>({
    currentStep: "template-selection",
    selectedTemplate: null,
    answers: [],
    currentQuestionIndex: 0,
    generatedDocument: null,
    isGenerating: false,
    error: null,
    progress: 0,
  });

  // Refs for managing async operations
  const abortControllerRef = useRef<AbortController | null>(null);

  // Template selection
  const selectTemplate = useCallback((template: DocumentTemplate) => {
    setState((prev) => ({
      ...prev,
      selectedTemplate: template,
      currentStep: "questionnaire",
      answers: [],
      currentQuestionIndex: 0,
      error: null,
    }));
  }, []);

  // Answer management
  const updateAnswer = useCallback(
    (questionId: string, value: DocumentAnswer["value"]) => {
      const answer: DocumentAnswer = {
        questionId,
        value,
        metadata: {
          updatedAt: new Date(),
        },
      };

      const validation = validateDocumentAnswer(answer);
      if (!validation.success) {
        setState((prev) => ({
          ...prev,
          error: `Invalid answer: ${validation.error.message}`,
        }));
        return;
      }

      setState((prev) => {
        const existingAnswerIndex = prev.answers.findIndex(
          (a) => a.questionId === questionId,
        );
        let newAnswers: DocumentAnswer[];

        if (existingAnswerIndex >= 0) {
          newAnswers = prev.answers.map((a, index) =>
            index === existingAnswerIndex ? answer : a,
          );
        } else {
          newAnswers = [...prev.answers, answer];
        }

        return {
          ...prev,
          answers: newAnswers,
          error: null,
        };
      });
    },
    [],
  );

  // Navigation
  const nextQuestion = useCallback(() => {
    setState((prev) => {
      if (!prev.selectedTemplate) return prev;

      const nextIndex = prev.currentQuestionIndex + 1;
      if (nextIndex >= prev.selectedTemplate.questions.length) {
        return {
          ...prev,
          currentStep: "generation",
          currentQuestionIndex: 0,
        };
      }
      return {
        ...prev,
        currentQuestionIndex: nextIndex,
      };
    });
  }, []);

  const previousQuestion = useCallback(() => {
    setState((prev) => ({
      ...prev,
      currentQuestionIndex: Math.max(0, prev.currentQuestionIndex - 1),
    }));
  }, []);

  // Document generation
  const generateDocument = useCallback(
    async (request: DocumentGenerationRequest) => {
      const validation = validateDocumentGenerationRequest(request);
      if (!validation.success) {
        setState((prev) => ({
          ...prev,
          error: `Invalid request: ${validation.error.message}`,
        }));
        return;
      }

      try {
        setState((prev) => ({
          ...prev,
          isGenerating: true,
          error: null,
          progress: 0,
        }));

        // Start generation
        const abortController = new AbortController();
        abortControllerRef.current = abortController;

        // Simulate progress updates
        const progressInterval = setInterval(() => {
          setState((prev) => ({
            ...prev,
            progress: Math.min(90, prev.progress + 10),
          }));
        }, 200);

        const response = await aiService.generateDocument(request);

        if (abortController.signal.aborted) {
          throw new Error("Generation cancelled");
        }

        clearInterval(progressInterval);

        setState((prev) => ({
          ...prev,
          generatedDocument: response.document,
          isGenerating: false,
          currentStep: "editing",
          progress: 100,
        }));
      } catch (error) {
        const errorMessage =
          error instanceof Error
            ? error.message
            : "Failed to generate document";
        setState((prev) => ({
          ...prev,
          isGenerating: false,
          error: errorMessage,
          progress: 0,
        }));
      } finally {
        abortControllerRef.current = null;
      }
    },
    [aiService],
  );

  // Document editing
  const updateDocument = useCallback((updates: Partial<Document>) => {
    setState((prev) => {
      if (!prev.generatedDocument) return prev;

      return {
        ...prev,
        generatedDocument: {
          ...prev.generatedDocument,
          ...updates,
          updatedAt: new Date(),
        },
      };
    });
  }, []);

  // Document export
  const exportDocument = useCallback(
    async (options: DocumentExportOptions) => {
      const validation = validateDocumentExportOptions(options);
      if (!validation.success) {
        setState((prev) => ({
          ...prev,
          error: `Invalid export options: ${validation.error.message}`,
        }));
        return;
      }

      if (!state.generatedDocument) {
        setState((prev) => ({
          ...prev,
          error: "No document to export",
        }));
        return;
      }

      try {
        setState((prev) => ({
          ...prev,
          isGenerating: true,
          error: null,
        }));

        // Simulate export process
        await new Promise((resolve) => setTimeout(resolve, 1500));

        // In a real implementation, this would trigger a download or save operation
        console.log("Exporting document:", {
          document: state.generatedDocument,
          options,
        });

        setState((prev) => ({
          ...prev,
          isGenerating: false,
          currentStep: "export",
        }));
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Failed to export document";
        setState((prev) => ({
          ...prev,
          isGenerating: false,
          error: errorMessage,
        }));
      }
    },
    [state.generatedDocument],
  );

  // Error management
  const setError = useCallback((error: string | null) => {
    setState((prev) => ({
      ...prev,
      error,
    }));
  }, []);

  // Step management
  const setCurrentStep = useCallback(
    (step: DocumentBuilderState["currentStep"]) => {
      setState((prev) => ({
        ...prev,
        currentStep: step,
      }));
    },
    [],
  );

  // Reset
  const reset = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    setState({
      currentStep: "template-selection",
      selectedTemplate: null,
      answers: [],
      currentQuestionIndex: 0,
      generatedDocument: null,
      isGenerating: false,
      error: null,
      progress: 0,
    });
  }, []);

  // Cleanup on unmount
  const cleanup = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
  }, []);

  return {
    // State
    state,

    // Actions
    selectTemplate,
    updateAnswer,
    nextQuestion,
    previousQuestion,
    generateDocument,
    updateDocument,
    exportDocument,
    reset,
    setError,
    setCurrentStep,
    cleanup,
  };
}

export type UseDocumentBuilderReturn = ReturnType<typeof useDocumentBuilder>;
